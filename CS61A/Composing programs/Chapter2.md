# 第2章：使用数据构建抽象

数据。使我们能够表示和操纵有关许多不同领域的信息。有效使用内置和用户定义的数据类型是数据处理应用程序的基础。

---

## 2.1 简介

### 2.1.1 原生数据类型

Python 包含三种原生数字类型：整数 ( `int` )、实数 ( `float` ) 和复数 ( `complex` )。

```python
>>>1 + 10000000000000
10000000000001
>>>type( 1.5 ) 
<class 'float'> 
>>>type( 1 + 1 j ) 
<class 'complex'>
```



## 2.2 数据抽象

数据抽象的基本思想是构造程序，使其对抽象数据进行操作。也就是说，我们的程序应该以尽可能少对数据做出假设的方式使用数据。同时，具体的数据表示被定义为程序的独立部分。



### 2.2.3  Abstraction Barriers（抽象屏障）

假设有理数作为一个抽象类型，不同层级使用不同程度的抽象

| 程序层级               | 将有理数视为  | 使用                     |
| ---------------------- | ------------- | ------------------------ |
| 使用有理数计算         | 整体          | mul_rational：有理数乘法 |
| 构造有理数对象，并管理 | 分子和分母    | rational，numer，denom   |
| 用于实现有理数的工具   | 长度为2的数组 | 数组操作                 |



在上面的每一层中，最后一列中的函数都强制执行抽象屏蔽。这些函数由较高级别调用，并使用较低级别的抽象实现。

当程序中可以使用更高级别函数的部分改用较低级别的函数时，就会发生抽象屏障违规。例如，计算有理数平方的函数最好用`mul_rational`来实现，它不对有理数的实现做任何假设。

```python
>>> def  square_rational ( x ):
return mul_rational ( x , x )          
```

直接引用分子和分母会打破一层抽象屏蔽。

```python
>>> def  square_rational_violating_once ( x ):
return rational ( numer ( x ) * numer ( x ), denom ( x ) * denom ( x ))              
```

假设有理数表示为双元素列表，并且直接使用数组操作，将会打破两层抽象。

```python
>>> def  square_rational_violating_twice ( x ):
return [ x [ 0 ] * x [ 0 ], x [ 1 ] * x [ 1 ]]              
```

抽象屏障使程序更易于维护和修改。依赖于特定表示的函数越少，当想要更改该表示时所需的更改就越少。square_rational 的所有这些实现都具有正确的行为，但只有第一个对未来的更改具有鲁棒性。即使我们改变了有理数的表示， `square_rational`函数也不需要更新。相比之下，只要选择器或构造函数签名发生变化， `square_rational_violating_once`就需要更改，而 只要有理数的实现发生变化`，``square_rational_violating_twice`就需要更新。





## 2.3 序列

序列是计算机科学中一个强大的基本抽象概念，是几种不同类型的数据之间共享的行为的集合

python中有一些内置的数据类型，属于序列



### 2.3.1 列表

```python
>>>num =  [ 1 ,  8 ,  2 ,  8 ] 
>>> len (num) 
4 
>>>num[ 3 ] 
8
>>> [ 2 ,  7 ]  + num *  2 
[2, 7, 1, 8, 2, 8, 1, 8, 2, 8]
>>>pair =  [[ 10 ,  20 ],  [ 30 ,  40 ]] 
>>>pair[ 1 ] 
[30, 40] 
>>>pair[ 1 ][ 0 ] 
30
```

### 2.3.2 序列迭代

**Range。**range是 Python 中另一种内置的序列类型，表示整数范围。Range由 range 创建,接受两个整数参数：左边界（闭） & 右边界（开）

如果只给一个参数，则默认为右边界，左边界为0

```python
>>> range ( 1 ,  10 )   # 包括 1，但不包括 10 
range(1, 10)

>>> list(range(4))
[0, 1, 2, 3]

>>> list(range(-1)) # 返回空序列，range默认的step为1, 则0永远无法迭代到-1
[]

>>> list(range(0,-2,-1)) # 设定迭代向量为-1，则可以生成序列
[0, -1]

>>> list(range(5, 8))
[5, 6, 7]
```

常见的约定是，在`for标头中对名称使用单个下划线字符：`如果不使用name

```python
>>> for _ in range(3): 
        print('加油！')
```



### 2.3.3  序列处理



python 序列表达式

```python
>>> odds = [1, 3, 5, 7, 9]
>>> [x+1 for x in odds]
[2, 4, 6, 8, 10]
```

python 序列聚合

```python
>>> def divisors(n):
        return [1] + [x for x in range(2, n) if n % x == 0]
>>> divisors(4)
[1, 2]
```

```python
>>> [[1] + s for s in [[4], [5, 6]]]
 [[1,4],[1,5,6]]
```

python 序列 + 高阶函数

```python
>>> [abs(x) for x in [-1,2] ]
[1, 2]
```





### 2.3.4 序列抽象

**成员资格。** 可以测试某个值是否属于某个序列。Python 有两个运算符`in`和`not in` ， 根据元素是否出现在序列中，它们的计算结果为`True`或`False 。`

```python
>>> digits
[1, 8, 2, 8]
>>> 2 in digits
True
>>> 1828 not in digits
True
```



**切片。**序列中包含较小的序列。序列的*切片*是原始序列的任意连续跨度，由一对整数指定。与`范围`构造函数一样，第一个整数表示切片的起始索引，第二个整数表示超出结束索引的索引。

在 Python 中，序列切片的表达方式与元素选择类似，使用方括号。冒号分隔起始索引和终止索引。任何省略的边界都被视为极值：起始索引为 0，终止索引为序列的长度。

```python
>>>digits[ 0 : 2 ] 
[1, 8] 
>>>digits[ 1 :] 
[8, 2, 8]
```



### 2.3.5 字符串

字符串文字可以表达任意文本，用单引号或双引号括起来。

```python
>>> city  =  'Berkeley' 
>>> len ( city ) 
8 
>>> city [ 3 ] 
'k'
```

加法 & 乘法

```python
>>> 'Berkeley' + ', CA'
'Berkeley, CA'
>>> 'Shabu ' * 2
'Shabu Shabu '
```



成员函数

```python
>>> 'here' in 'where'
True	
```

**多行文字。**字符串不限于一行。三重引号分隔跨多行的字符串文字。我们已经在文档字符串中广泛使用了这种三重引号。

```python
>>> """ hi
 hi"""
' hi\nhi'
```

**字符串强制转换**

```python
>>> str(2) + ' is an element of ' + str(digits)
'2 is an element of [1, 8, 2, 8]'
```

### 2.3.6  树

用list 递归构造

### 2.3.7 链表

用list 递归构造